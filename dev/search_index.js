var documenterSearchIndex = {"docs":
[{"location":"requests/#Requests-Layer","page":"Requests","title":"Requests Layer","text":"","category":"section"},{"location":"requests/","page":"Requests","title":"Requests","text":"CurrentModule = QiskitRuntime.Requests","category":"page"},{"location":"requests/","page":"Requests","title":"Requests","text":"Modules = [Requests]","category":"page"},{"location":"requests/#QiskitRuntime.Requests","page":"Requests","title":"QiskitRuntime.Requests","text":"module Requests\n\nThis module manages requests and responses to the REST API.\n\nSeveral functions in the Requests layer make requests to specific endpoints. For some endpoints, responses are cached as JSON text files. A request to an endpoint with a cache works as follows:\n\nA function requesting a specific endpoint is called. For example job. In this case, a job id is passed as a parameter.\nThe cached response is looked up by job id. If a cached response is found, it is read, converted to a JSON3.Object, and returned.\nIf the cached reponse is not found, a request is made to the endpoint. The response string is written to the cache and is also converted to a JSON3.Object and returned.\n\nIf you pass the keyword parameter refresh=true, the above scenario is modified. In this case, the request is sent to the endpoint unconditionally. The cache file, if present, is overwritten with the new reponse.\n\nSome endpoints have no associated cache. A function in the Requests layer accessing this endpoint simply makes the requests, parses the result, and returns a JSON3.Object.\n\nThe following two arguments are common to many functions in the API of the Requests layer.\n\nArguments\n\n– qaccount::Union{QuantumAccount, Nothing}=nothing: The QuantumAccount to use. If nothing     a QuantumAccount is created.\n\nKeyword arguments\n\n– refresh::Bool=false:  If false, then a cached response will be preferred. If true,     the a request will be made, and the cache will be updated with a fresh response.\n\nOptions to requests\n\nMany endpoints in the REST API support options, such as filters. Most of these are not yet implemented, although it is not difficult to do so.\n\nwarning: Warning\nNo measures are taken to protect the cache from corruption in case of errors.\n\n\n\n\n\n","category":"module"},{"location":"requests/#QiskitRuntime.Requests.backends","page":"Requests","title":"QiskitRuntime.Requests.backends","text":"backends(qaccount=nothing; provider=nothing)::JSON3.Object\n\nReturn list of backends available to the configured user and instance.\n\nIf provider is :all, then return all backends, even those not available  to the instance.\n\nI'm pretty sure that \"provider\" and \"instance\" mean the same thing.\n\nendpoint: \"backends\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.cached_job_ids-Tuple{}","page":"Requests","title":"QiskitRuntime.Requests.cached_job_ids","text":"cached_job_ids()::Generator{Vector{String}}\n\nReturn an iterator over all the job ids associated with cached job info.\n\nThese are the ids of jobs that were fetched via job or jobs.\n\n\n\n\n\n","category":"method"},{"location":"requests/#QiskitRuntime.Requests.job","page":"Requests","title":"QiskitRuntime.Requests.job","text":"job(job_id, qaccount=nothing; refresh=false)::JSON3.Object\n\nRetrieve job info for job_id\n\nendpoint: \"job/{job_id}\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.job_ids","page":"Requests","title":"QiskitRuntime.Requests.job_ids","text":"job_ids(qaccount=nothing; kws...)::Vector{String}\n\nReturn all job ids.\n\nThe function jobs is called to retrieve the job info and the ids are extracted and returned.\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.jobs","page":"Requests","title":"QiskitRuntime.Requests.jobs","text":"jobs(qaccount=nothing; tags=nothing)\n\nReturn job info on all jobs.\n\nendpoint: \"jobs\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.metrics","page":"Requests","title":"QiskitRuntime.Requests.metrics","text":"metrics(job_id, qaccount=nothing)::JSON3.Object\n\nReturn metrics for job_id.\n\nendpoint: \"jobs/{job_id}/metrics\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.results","page":"Requests","title":"QiskitRuntime.Requests.results","text":"results(job_id, qaccount=nothing; refresh=false)::JSON3.Object\n\nReturn the job results for job_id.\n\nendpoint: \"jobs/{job_id}/results\"\n\nThe other kind of data on a job, which we call \"job info\", is retrieved with job, or jobs\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.transpiled_circuits","page":"Requests","title":"QiskitRuntime.Requests.transpiled_circuits","text":"transpiled_circuits(job_id, qaccount=nothing)::JSON3.Object\n\nReturn transpiled circuits for job_id.\n\nendpoint: \"jobs/{job_id}/transpiled_circuits\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.user","page":"Requests","title":"QiskitRuntime.Requests.user","text":"user(qaccount=nothing)::JSON3.Object\n\nGet the authenticated user.\n\nThe reponse includes the user's email and the same information returned by user_instances.\n\nendpoint: \"users/me\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.user_instances","page":"Requests","title":"QiskitRuntime.Requests.user_instances","text":"user_instances(qaccount=nothing)::JSON3.Object\n\nReturn a list of instances available to the user.\n\nendpoint: \"instances\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.user_jobs","page":"Requests","title":"QiskitRuntime.Requests.user_jobs","text":"user_jobs(qaccount=nothing)::JSON3.Object\n\nMysterious alternative to jobs that returns slightly different results.\n\nendpoint: \"facade/v1/jobs\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.workloads","page":"Requests","title":"QiskitRuntime.Requests.workloads","text":"workloads(qaccount=nothing; instance=nothing)::JSON3.Object\n\nList user workloads\n\nCompared to jobs, workloads returns a smaller dictionary with less information for each job.\nThe default filters are different. Not just the limit on the number of returned jobs.\nendpoint: \"workloads/me\"\n\n\n\n\n\n","category":"function"},{"location":"requests/","page":"Requests","title":"Requests","text":"","category":"page"},{"location":"dev_notes/#Development-notes","page":"Development notes","title":"Development notes","text":"","category":"section"},{"location":"dev_notes/#Native-Julia-types","page":"Development notes","title":"Native Julia types","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"The REST API is Python-centric in a few ways. Numerical data is typically numpy data that is serialized, compressed, and encoded.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"We currently support much of this with conversion to native-Julia types","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"numpy arrays are converted to Array\nPauli strings represented as un-processed strings by the REST API, eg. \"IXYZ\" are converted to PauliOperator (see below).\nBit-register samples (shots) are designed for compatibility with Qiskit's BitArray (or the other way around). We have a custom type with the same semantics and memory layout (more or less) in src/bitarraysx.jl. This has some associated functionality, but it is limited compared to, say, Base.BitArray. At present, a fallback conversion via BitArray(our_custom_array) works, and is not terribly inefficient if you don't do it much. We may want take a different approach. Eg, go directly to BitArray, or...\nQuantumCircuit. We leave this in the same form we get it from the REST API. A string of the serialized-compressed-encoded data.\nQASM3 programs. These are handled by the REST API as plain strings with no encoding. (maybe QASM3 allows utf-8, which receives standard encoding, IDK). We do nothing with this at the moment other than store it.","category":"page"},{"location":"dev_notes/#Precompile","page":"Development notes","title":"Precompile","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"precompile.jl script works by processing cached jobs in your ~/.qiskit directory. (We cache REST responses there, the Python client does not) If you have no cached jobs, then precompilation should still succeed, but it will not be of any benefit.\nThis is not a good general solution. If someone installs the package, they will have no cached jobs, and so get no benefit.","category":"page"},{"location":"dev_notes/#Name-spaces","page":"Development notes","title":"Name spaces","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Using modules to understand dependencies, and everything else good that they bring. I also want to keep symbols intended to be private out of the REPL TAB completion, and other prying tools. There are various methods in Julia-world to try to do this. I am sort of experimenting in an adhoc way","category":"page"},{"location":"dev_notes/#Data-structures","page":"Development notes","title":"Data structures","text":"","category":"section"},{"location":"dev_notes/#Dicts","page":"Development notes","title":"Dicts","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Discourage free-form dicts with string keys. Constrain values of inputs by construction. Eg. in Python, \"measure_noiselearning\" instead of \"measure_noise_learning\" gives an inscrutable error.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Of course, on the other hand, dict-based structures are easy to implement and change.","category":"page"},{"location":"dev_notes/#Version-numbers","page":"Development notes","title":"Version numbers","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"I am using VersionNumber rather than Int. There are stories in the software world of headaches that arise when people want to tighten up loose version number rules.","category":"page"},{"location":"dev_notes/#Bits-and-bit-base-storage","page":"Development notes","title":"Bits and bit-base storage","text":"","category":"section"},{"location":"dev_notes/#BitIntegers","page":"Development notes","title":"BitIntegers","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Has poor performance for some operations for large numbers of bits, say greater than UInt1024. I don't know how easy it would be to work around some of these. But I want to avoid even trying. There is at least one QC Julia package that uses these types for Pauli operators. For example: rand(UInt16384) fails to return in less than a several of minutes. I did not wait to see if it returns. I think this may be inefficient compilation. rand(UInt8192) takes about a minute for the first one. Then is much faster. But an order of mag longer than a corresponding array of UInt64. Seems to be an algorithmic inefficiency in compiling.","category":"page"},{"location":"dev_notes/#Pauli-operators","page":"Development notes","title":"Pauli operators","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"I have vendored PauliOperator from QuantumClifford.jl. The whole package is a bit heavier than I want at the moment. For most operations (but not all) PauliOperator is very fast, competitive with stim.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Sums of Pauli operators (or tables, etc.) Can be represented efficiently if the storage for each string is static and of the same size. Then they will be stored inline in a Vector. If we use dynamic storage, like a Vector{UInt64} or BitArray, then we probably do not want a Vector of our string type. They would not be stored inline. Unfortunately this story in Julia is not as good as it could be. There is some discussion about improvements, but they are not here yet.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Pauli type in QuantumClifford has good features, but bad perf in indexing ranges: data[1:10] My current experiment with storing data as a BitArray is 10x faster for this operation","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"I think the best for the moment is to depend on QuantumClifford. It is much bigger than just the relatively small code supporting Paulis. Some performance issues can be fixed easily outside of the package.","category":"page"},{"location":"dev_notes/#Load-times-and-[TTFX](https://www.google.com/search?qjuliattfx)","page":"Development notes","title":"Load times and TTFX","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"At the moment, I am trying vendoring to keep load and TTFX down. I plan to try Julia package Extensions","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Load times. I want to pay attention to load times, because this will be compared to the Python version.\nQuantumClifford – 1.3s. We use only a small part, PauliOperator. So, I vendored this.\nAccessors – 150ms this makes code much cleaner and easier to both read and write. But it depends  on InverseFunctions, which does compilation.\nPrecompileTools. This is working well to make TTFX very low. (EDIT: There has been a regression.  But the TTFX is still lower than it would be otherwise. I suspect we need more concrete type annotations.)","category":"page"},{"location":"dev_notes/#Performance","page":"Development notes","title":"Performance","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"LazyString: remember to use these when throwing exceptions.","category":"page"},{"location":"dev_notes/#Iterators-vs-containers","page":"Development notes","title":"Iterators vs containers","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"People, including myself, have noted that in Julia we miss the support for iterators that we find in Rust, and the culture around it. In Julia you have unnecessary allocation in chained operations on collections. I suspect that part of this difference is due to Julia playing two roles: one, a programming language; and two, an interactive tool. In the latter, containers are more convenient.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Still, I'd like to try to use more lazy containers. For example, I am trying this when returning things from the Requests layer. Since this layer is intended to be used primarily programmatically rather than interactively, you don't lose much convenience in returning, say Generator{Vector}.","category":"page"},{"location":"dev_notes/#Exceptions","page":"Development notes","title":"Exceptions","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Julia doesn't have a strong culture or concepts of best practices for exceptions.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Make our own exceptions, or use built in? When to use them?\nOr use an Option type?","category":"page"},{"location":"dev_notes/#Sum/Algebraic-types","page":"Development notes","title":"Sum/Algebraic types","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Speaking of Option types. How about a sum type?  These are often really useful.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"LightSumTypes.jl is very small (50 lines or so) and very performant, but lacks features.","category":"page"},{"location":"dev_notes/#Code-quality-and-CI","page":"Development notes","title":"Code quality and CI","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Testing REST API. I think some kind mocking framework may be necessary.\nAqua.jl currently in use in this package.\nJET.jl. Would be a good idea. It is currently a bit painful to set up.\nQuantumClifford.jl","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"is an example of a Julia package that uses a bunch of GH Actions CI tools to enforce code quality","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Enforced formatting? This is probably a good idea. I have not yet tried it. There is a newish package, Runic.jl, I think that is a config-less code formatter.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"As far as I can tell, there is no syntax that works with Documenter.jl for making comments that are not rendered in the final html. There might be some way, but I have discussions online with no resolution. This is unfortunate:","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"<!–  LocalWords:  centric numpy un eg IXYZ PauliOperator Qiskit's BitArray src QASM3 utf   LocalWords:  QuantumCircuit IDK Precompile precompile jl qiskit precompilation REPL   LocalWords:  adhoc Dicts dicts noiselearning VersionNumber BitIntegers UInt1024 10x   LocalWords:  UInt16384 UInt8192 UInt64 vendored QuantumClifford stim perf Paulis 3s   LocalWords:  TTFX ttfx vendoring Accessors 150ms InverseFunctions PrecompileTools   LocalWords:  LazyString programmatically LightSumTypes performant GH newish config   LocalWords:  formatter –>","category":"page"},{"location":"#QiskitRuntime.jl","page":"Introduction","title":"QiskitRuntime.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThis documentation is not for the standard client qiskit-ibm-runtime to the Qiskit Runtime REST APITo find information on the easiest, best, way to use the Qiskit Runtime use this link:qiskit-ibm-runtimeThe documentation you are reading now is only for the highly experimental Julia-language client, not for the Python-langauge client.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nDocumentation pages for QiskitRuntime.jl are a WIP.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using QiskitRuntime\nend","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The contents are jumbled and out of order. Documenter is difficult.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 2","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime]","category":"page"},{"location":"#QiskitRuntime.QiskitRuntime","page":"Introduction","title":"QiskitRuntime.QiskitRuntime","text":"module QiskitRuntime\n\nQiskitRuntime is a client for the Qiskit Runtime REST API written in the Julia language.\n\nQiskitRuntime is analagous to the Python-language client qiskit-ibm-runtime.\n\nwarning: Warning\nQiskitRuntime is very new, incomplete, and API-unstable.QiskitRuntime.jl is completely unsupported. No person or entity is responsible for providing any support to users of this software.\n\nFurthermore, the focus at the moment is more on retreiving data than on submitting workloads.\n\nEnvironment variables\n\nThe following environment variables override defaults.\n\nQISKIT_RUNTIME_CACHE_DIR: The top-level directory where REST responses are cached.\nQISKIT_IBM_URL: The url used for authentication (not for REST endpoints).\nQISKIT_IBM_CHANNEL:\nQISKIT_IBM_INSTANCE: In the form \"hub/group/project\".\nQISKIT_IBM_TOKEN: The authentication token\n\n\n\n\n\n","category":"module"},{"location":"#Jobs","page":"Introduction","title":"Jobs","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime.Jobs]","category":"page"},{"location":"#QiskitRuntime.Jobs.cached_job_ids-Tuple{}","page":"Introduction","title":"QiskitRuntime.Jobs.cached_job_ids","text":"cached_job_ids()\n\nReturn an iterator over JobIds of cached jobs.\n\nUse job_ids to request ids from the REST API.\n\n\n\n\n\n","category":"method"},{"location":"#QiskitRuntime.Jobs.cached_jobs-Tuple{}","page":"Introduction","title":"QiskitRuntime.Jobs.cached_jobs","text":"cached_jobs(; params::Bool=true, results::Bool=true)\n\nReturn an iterator over all cached jobs.\n\nparams: If true include job input parameters (including the pubs).  Otherwise the field params has           value nothing.\nresults: If true get the job results, if available. Otherwise, the field results has value nothing.\n\n\n\n\n\n","category":"method"},{"location":"#QiskitRuntime.Jobs.job","page":"Introduction","title":"QiskitRuntime.Jobs.job","text":"job(job_id::JobId, account=nothing;  params::Bool=true, results::Bool=true, refresh::Bool=false)::RuntimeJob\n\nReturn information on job_id.\n\nparams: If true include job input parameters (including the PUBs)).           Otherwise the field params has value nothing.\nresults: If true get the job results, if available. Otherwise, the field results has value nothing.            Results are retrieved via the function results.\nrefresh: If true fetch job info and results from the REST API, rather than from cache.            This also updates the cache. If refresh is false, then the cache is preferred.\n\nSee results\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.job-2","page":"Introduction","title":"QiskitRuntime.Jobs.job","text":"job(job_in::RuntimeJob, account=nothing;  params::Bool=true, results::Bool=true, refresh::Bool=false)::RuntimeJob\n\nReturn information on job_in.\n\nThe fields job_in.params and job_in.results may have value nothing. Use this method to return a copy of job_in with one or both of these fields populated, according to the keyword arguments params and results. These keyword arguments are described in job\n\nnote: Note\nThis function would be more useful if it were optimized to fetch only the needed additional data, copying the rest from jobin. In fact, at present, it constructs the entire RuntimeJob from scratch.\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.job_ids","page":"Introduction","title":"QiskitRuntime.Jobs.job_ids","text":"job_ids(account=nothing)\n\nReturn an iterator over JobIds for all jobs.\n\njob_ids first requests all the information on the jobs, then extracts the ids. This function always makes requests to the REST API and does not access the cache.\n\nUse cached_job_ids to get ids only for cached job requests.\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.results","page":"Introduction","title":"QiskitRuntime.Jobs.results","text":"results(job_id, account=nothing; refresh=false)\n\nReturn results for job_id.\n\nSee job\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.results-2","page":"Introduction","title":"QiskitRuntime.Jobs.results","text":"results(job::RuntimeJob, account=nothing; refresh=false)\n\nReturn results associated with job.\n\nResults already contained in job are returned if it makes sense to do so.\n\nMore precisely, if job.results is not nothing and refresh is false, then job.results is returned. If job.results is nothing then results are fetched from the cache or the REST API. If refresh is false then the cache is preferred.\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.user","page":"Introduction","title":"QiskitRuntime.Jobs.user","text":"user(account=nothing)\n\nReturn information about the user.\n\nInformation includes the user's email and a list of available instances.\n\n\n\n\n\n","category":"function"},{"location":"#Backends","page":"Introduction","title":"Backends","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime.Backends]","category":"page"},{"location":"#QiskitRuntime.Backends.backend_status","page":"Introduction","title":"QiskitRuntime.Backends.backend_status","text":"backend_status(backend_name::AbstractString, account=nothing)\n\nReturn status information of backend_name.\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Backends.backends","page":"Introduction","title":"QiskitRuntime.Backends.backends","text":"backends(account=nothing; pending=false, testing=false, instance=nothing)\n\nReturn a list of available backends.\n\npending: If true, return a list of tuples  (name, num_pending_jobs) sorted by num_pending_jobs.\ntesting: If true include test devices, those that begin with \"test_\".\n\n\n\n\n\n","category":"function"},{"location":"#Accounts","page":"Introduction","title":"Accounts","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime.Accounts]","category":"page"},{"location":"#QiskitRuntime.Accounts.QuantumAccount","page":"Introduction","title":"QiskitRuntime.Accounts.QuantumAccount","text":"struct that represents an account with channel 'ibm_quantum.'\"\n\n\n\n\n\n","category":"type"},{"location":"#QiskitRuntime.Accounts.QuantumAccount-Tuple{}","page":"Introduction","title":"QiskitRuntime.Accounts.QuantumAccount","text":"QuantumAccount()\n\nReturn a structure that contains information necessary for making requests to the REST API. This includes an access token and an instance.\n\nThis reads ~/.qiskit/qiskit-ibm.json. Environment variables take precedent. The latter has been implemented but is not tested.\n\n\n\n\n\n","category":"method"},{"location":"#QiskitRuntime.Accounts.UserId-Tuple{AbstractString}","page":"Introduction","title":"QiskitRuntime.Accounts.UserId","text":"UserId(id_str::AbstractString)\n\nConstruct user id from the user id string in REST response.\n\n\n\n\n\n","category":"method"},{"location":"#Instances","page":"Introduction","title":"Instances","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime.Instances]","category":"page"},{"location":"#QiskitRuntime.Instances.Instance-Tuple{AbstractString}","page":"Introduction","title":"QiskitRuntime.Instances.Instance","text":"Instance(instance::AbstractString)\n\nConstruct an Instance from a string of the form \"hub/group/project\".\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is not a really tutorial. It's a demonstration of a few things that you can try","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nThis tutorial assumes you have valid account info in ~/.qiskit/qiskit-ibm.json.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nI would be surprised if this works for you on the first attempt. This was all developed in a particular environment, with a particular subset of the data returned by the REST API.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pull in a lot of symbols.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using QiskitRuntime","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also get exported symbols from only one module, e.g. using QiskitRuntime.Jobs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Retrieve job ids from the server. Note that an iterator is returned. So we use collect.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ajob_ids = collect(job_ids());\n\njulia> print(ajob_ids[1:5])\nJobId[JobId(\"cxp4fhy0v15000804nsg\"), JobId(\"cxp4fhpwk6yg008hjy5g\"), JobId(\"cxd6a7rbqkhg008kef50\"), JobId(\"cxd6a70pjw30008g32y0\"), JobId(\"cxd6a60px23g008t7nz0\")]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Fetch the \"jobs\", that is input information and results, for each job id. Note that we choose to throw the returned objects away. But they are cached in ~/.qiskit/runtime_cache.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> foreach(jid -> job(jid; refresh=true), ajob_ids)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We used refresh=true to make sure we fetch data from the server, not from the cache.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can get the (freshly) cached job ids like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> jids = collect(cached_job_ids()); length(jids)\n39\n\njulia> jid = jids[end]\nJobId(\"cxp4fhy0v15000804nsg\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now fetching the GET response from the cache, and decoding it (including native Julia types) is fast, even though it is not optimized at all.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @btime job($jid);\n  414.767 μs (12001 allocations: 564.11 KiB)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In general, job(jid) will build a big nested object. So I don't print one of them here. However, you can request that the results and job parameters params (including the input PUBs) be omitted.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> job(jid; results=false, params=false)\nRuntimeJob{Nothing, Nothing}(\n  job_id = JobId(\"cxp4fhy0v15000804nsg\"),\n  user_id = QiskitRuntime.Accounts.UserId(\"XXXXXXXXXXXXXXXXXXXXXXXX\"),\n  session_id = JobId(\"cxp4fh64a290008xg4r0\"),\n  primitive_id = Estimator::PrimitiveType = 0,\n  backend_name = \"ibm_brisbane\",\n  creation_date = 2024-12-25T17:58:31.640,\n  end_date = 2024-12-25T18:12:12.882,\n  instance = Instance(my-hub/my-group/my-project),\n  status = Done::JobStatus = 2,\n  cost = 18000,\n  private = false,\n  tags = [\"everything\", \"PEC\", \"Container Tests\"],\n  params = nothing,\n  results = nothing\n)","category":"page"}]
}
