var documenterSearchIndex = {"docs":
[{"location":"env_vars/#environment_variables","page":"Environment Variables","title":"Environment Variables","text":"","category":"section"},{"location":"env_vars/","page":"Environment Variables","title":"Environment Variables","text":"Modules = [QiskitRuntime.EnvVars]","category":"page"},{"location":"env_vars/#QiskitRuntime.EnvVars","page":"Environment Variables","title":"QiskitRuntime.EnvVars","text":"module EnvVars\n\nEnforce documentation and a safe interface to the environment variables used by QiskitRuntime.jl\n\n\"safe\" means that typos in environment variable names will result in immediate run time or compile time errors.\n\n\n\n\n\n","category":"module"},{"location":"env_vars/#QiskitRuntime.EnvVars.env_vars-Tuple{}","page":"Environment Variables","title":"QiskitRuntime.EnvVars.env_vars","text":"env_vars()\n\nReturn a Dict of all environment variables used by QiskitRuntime.jl and their values.\n\nIf the environment variable is not set then its value is nothing in the returned Dict. Here \"not set\" means it is not a key in Base.ENV.\n\nVariables:\n\nQISKIT_USER_DIR - The directory storing user data for Qiskit Runtime, including credentials and cache.\n\nQISKIT_ACCOUNT_NAME - The name of the account in the credentials file to use by default.\n\nQISKIT_IBM_INSTANCE - The instance (\"hub/group/project\") used only when setting the account via environment variables.\n\nQISKIT_IBM_TOKEN - The token, or API key, used only when setting the account via environment variables.\n\nQISKIT_RUNTIME_CACHE_DIR - The full path of the REST API response cache overriding the default HOME/.qiskit/runtime_cache.\n\nQISKIT_IBM_CHANNEL - The channel name used only when setting the account via environment variables. Currently unused by QiskitRuntime.jl\n\nQISKIT_IBM_AUTH_URL - The url used for authentication. Currently unused by QiskitRuntime.jl\n\nQISKIT_IBM_RUNTIME_LOG_LEVEL - Currently unused by QiskitRuntime.jl\n\n\n\n\n\n","category":"method"},{"location":"env_vars/#QiskitRuntime.EnvVars.get_env","page":"Environment Variables","title":"QiskitRuntime.EnvVars.get_env","text":"get_env(name::Symbol, default=nothing)\n\nReturn the value for environment variable name, or default if name is not present.\n\nnote: Note\nAn error is thrown if name is not an environment variable used by QiskitRuntime.jl.\n\n\n\n\n\n","category":"function"},{"location":"env_vars/#QiskitRuntime.EnvVars.set_env!-Tuple{Symbol, Union{Nothing, AbstractString}}","page":"Environment Variables","title":"QiskitRuntime.EnvVars.set_env!","text":"set_env!(name::Symbol, val::Union{AbstractString, Nothing})\n\nSet the value for environment variable name to val.\n\nIf val is nothing, then name is deleted from Base.ENV.\n\nnote: Note\nAn error is thrown if name is not an environment variable used by QiskitRuntime.jl.\n\n\n\n\n\n","category":"method"},{"location":"ids/#ids_tokens","page":"Id Numbers and Tokens","title":"Id Numbers and Tokens","text":"","category":"section"},{"location":"ids/","page":"Id Numbers and Tokens","title":"Id Numbers and Tokens","text":"Modules = [QiskitRuntime.Ids]","category":"page"},{"location":"ids/#QiskitRuntime.Ids","page":"Id Numbers and Tokens","title":"QiskitRuntime.Ids","text":"module Ids\n\nThis module implements identification numbers and related objects.\n\nstructs implemented here include: JobId, UserId, and Ids.Token.\n\nnote: Note\nWe may want to expose less from this module than we do at present. For example, generating bogus ids is useful for mocking, but probabaly not for most users.\n\n\n\n\n\n","category":"module"},{"location":"ids/#QiskitRuntime.Ids.JobId","page":"Id Numbers and Tokens","title":"QiskitRuntime.Ids.JobId","text":"struct JobId\n\nWrapper type for job ids\n\nBecause a session id is the first job id in a batch, JobId is used for session id as well. The data is stored as a string that is validated on construction.\n\nNote that passing validation is a necessary, but not sufficient condition for distinguishing job ids returned by the server. We could investigate the format of job ids and tighten up the validation.\n\nSee validate\n\n\n\n\n\n","category":"type"},{"location":"ids/#QiskitRuntime.Ids.Token","page":"Id Numbers and Tokens","title":"QiskitRuntime.Ids.Token","text":"struct Token\n\nWraps authentication tokens.\n\nThe server and the web dashboard express tokens as strings of 128 lower-case hexadecimal digits. We store this as eight UInt64s. In particular, the Token is validated upon construction.\n\nUppercase hexadecimal characters are allowed when parsing.\n\njulia> typeof(Token(\"884fad8b23e0cb2e19ae5df80aab5003e968ea4e3a69c6efce9a776b26cb157bb7456b189a964bdba89423ecb2e7b4d23c2644a672c9ba6ef2a1551bed5879d3\"))\nToken\n\njulia> Token(\"abc123\")\nERROR: ArgumentError: Token must be 128 hex digits\n\njulia> Token(\"ABCDAD8B23E0CB2E19AE5DF80AAB5003E968EA4E3A69C6EFCE9A776B26CB157BB7456B189A964BDBA89423ECB2E7B4D23C2644A672C9BA6EF2A1551BED5879D3\")\nToken(\"abcdad8b23e0cb2e19ae5df80aab5003e968ea4e3a69c6efce9a776b26cb157bb7456b189a964bdba89423ecb2e7b4d23c2644a672c9ba6ef2a1551bed5879d3\")\n\n\n\n\n\n","category":"type"},{"location":"ids/#QiskitRuntime.Ids.UserId","page":"Id Numbers and Tokens","title":"QiskitRuntime.Ids.UserId","text":"struct UserId\n\nWraps a user id.\n\nThe server returns 24 hex digits. We encode this as 96 bits in three UInt32s. Thus, validation occurs on construction.\n\n\n\n\n\n","category":"type"},{"location":"ids/#Base.rand-Tuple{Random.AbstractRNG, Random.SamplerType{JobId}}","page":"Id Numbers and Tokens","title":"Base.rand","text":"Random.rand(rng::Random.AbstractRNG, ::Random.SamplerType{JobId})\n\nReturn a random JobId.\n\nThe set of strings sampled is actually larger than that of true job ids. See JobId.\n\n\n\n\n\n","category":"method"},{"location":"ids/#Base.rand-Tuple{Random.AbstractRNG, Random.SamplerType{Token}}","page":"Id Numbers and Tokens","title":"Base.rand","text":"Random.rand(rng::Random.AbstractRNG, ::Random.SamplerType{Token}) =\n\nGenerate a random Token.\n\nThis might be useful for putting a bogus token in your credentials file.\n\n\n\n\n\n","category":"method"},{"location":"ids/#Base.rand-Tuple{Random.AbstractRNG, Random.SamplerType{UserId}}","page":"Id Numbers and Tokens","title":"Base.rand","text":"Random.rand(rng::Random.AbstractRNG, ::Random.SamplerType{UserId}) =\n\nConstruct a random UserId.\n\nThis is done by generating and wrapping three UInt32s.\n\nnote: Note\nWe may not want to expose this. It is used for mocking data.\n\n\n\n\n\n","category":"method"},{"location":"ids/#QiskitRuntime.Ids.validate-Tuple{Type{JobId}, AbstractString}","page":"Id Numbers and Tokens","title":"QiskitRuntime.Ids.validate","text":"validate(::Type{JobId}, job_id::AbstractString)\n\nReturn true if job_id is a valid job id.\n\njob_id must be a twenty digit string of 0-9 and a-z. There may be other restrictions, but we don't know about them and cannot check them.\n\n\n\n\n\n","category":"method"},{"location":"theindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"theindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"requests/#Requests-Layer","page":"Requests","title":"Requests Layer","text":"","category":"section"},{"location":"requests/","page":"Requests","title":"Requests","text":"CurrentModule = QiskitRuntime.Requests","category":"page"},{"location":"requests/","page":"Requests","title":"Requests","text":"Modules = [Requests]","category":"page"},{"location":"requests/#QiskitRuntime.Requests","page":"Requests","title":"QiskitRuntime.Requests","text":"module Requests\n\nThis module manages requests and responses to the REST API.\n\nSeveral functions in the Requests layer make requests to specific endpoints. For some endpoints, responses are cached as JSON text files. A request to an endpoint with a cache works as follows:\n\nA function requesting a specific endpoint is called. For example job. In this case, a job id is passed as a parameter.\nThe cached response is looked up by job id. If a cached response is found, it is read, converted to a JSON3.Object, and returned.\nIf the cached reponse is not found, a request is made to the endpoint. The response string is written to the cache and is also converted to a JSON3.Object and returned.\n\nIf you pass the keyword parameter refresh=true, the above scenario is modified. In this case, the request is sent to the endpoint unconditionally. The cache file, if present, is overwritten with the new reponse.\n\nSome endpoints have no associated cache. A function in the Requests layer accessing this endpoint simply makes the requests, parses the result, and returns a JSON3.Object.\n\nThe following two arguments are common to many functions in the API of the Requests layer.\n\nArguments\n\n– qaccount::Union{QuantumAccount, Nothing}=nothing: The QuantumAccount to use. If nothing     a QuantumAccount is created.\n\nKeyword arguments\n\n– refresh::Bool=false:  If false, then a cached response will be preferred. If true,     the a request will be made, and the cache will be updated with a fresh response.\n\nOptions to requests\n\nMany endpoints in the REST API support options, such as filters. Most of these are not yet implemented, although it is not difficult to do so.\n\nwarning: Warning\nNo measures are taken to protect the cache from corruption in case of errors.\n\n\n\n\n\n","category":"module"},{"location":"requests/#QiskitRuntime.Requests.backends","page":"Requests","title":"QiskitRuntime.Requests.backends","text":"backends(qaccount=nothing; provider=nothing)::JSON3.Object\n\nReturn list of backends available to the configured user and instance.\n\nIf provider is :all, then return all backends, even those not available  to the instance.\n\nI'm pretty sure that \"provider\" and \"instance\" mean the same thing.\n\nendpoint: \"backends\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.cached_job_ids-Tuple{}","page":"Requests","title":"QiskitRuntime.Requests.cached_job_ids","text":"cached_job_ids()::Generator{Vector{String}}\n\nReturn an iterator over all the job ids associated with cached job info.\n\nThese are the ids of jobs that were fetched via job or jobs.\n\n\n\n\n\n","category":"method"},{"location":"requests/#QiskitRuntime.Requests.job","page":"Requests","title":"QiskitRuntime.Requests.job","text":"job(job_id, qaccount=nothing; refresh=false)::JSON3.Object\n\nRetrieve job info for job_id\n\nendpoint: \"job/{job_id}\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.job_ids","page":"Requests","title":"QiskitRuntime.Requests.job_ids","text":"job_ids(qaccount=nothing; kws...)::Vector{String}\n\nReturn all job ids.\n\nThe function jobs is called to retrieve the job info and the ids are extracted and returned.\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.jobs","page":"Requests","title":"QiskitRuntime.Requests.jobs","text":"jobs(qaccount=nothing; tags=nothing)\n\nReturn job info on all jobs.\n\nendpoint: \"jobs\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.metrics","page":"Requests","title":"QiskitRuntime.Requests.metrics","text":"metrics(job_id, qaccount=nothing)::JSON3.Object\n\nReturn metrics for job_id.\n\nendpoint: \"jobs/{job_id}/metrics\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.results","page":"Requests","title":"QiskitRuntime.Requests.results","text":"results(job_id, qaccount=nothing; refresh=false)::JSON3.Object\n\nReturn the job results for job_id.\n\nendpoint: \"jobs/{job_id}/results\"\n\nThe other kind of data on a job, which we call \"job info\", is retrieved with job, or jobs\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.transpiled_circuits","page":"Requests","title":"QiskitRuntime.Requests.transpiled_circuits","text":"transpiled_circuits(job_id, qaccount=nothing)::JSON3.Object\n\nReturn transpiled circuits for job_id.\n\nendpoint: \"jobs/{job_id}/transpiled_circuits\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.user_info","page":"Requests","title":"QiskitRuntime.Requests.user_info","text":"user_info(qaccount=nothing; refresh=false)::JSON3.Object\n\nGet the authenticated user.\n\nThe reponse includes the user's email and the same information returned by user_instances.\n\nendpoint: \"users/me\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.user_instances","page":"Requests","title":"QiskitRuntime.Requests.user_instances","text":"user_instances(qaccount=nothing)::JSON3.Object\n\nReturn a list of instances available to the user.\n\nendpoint: \"instances\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.user_jobs","page":"Requests","title":"QiskitRuntime.Requests.user_jobs","text":"user_jobs(qaccount=nothing)::JSON3.Object\n\nMysterious alternative to jobs that returns slightly different results.\n\nendpoint: \"facade/v1/jobs\"\n\n\n\n\n\n","category":"function"},{"location":"requests/#QiskitRuntime.Requests.workloads","page":"Requests","title":"QiskitRuntime.Requests.workloads","text":"workloads(qaccount=nothing; instance=nothing)::JSON3.Object\n\nList user workloads\n\nCompared to jobs, workloads returns a smaller dictionary with less information for each job.\nThe default filters are different. Not just the limit on the number of returned jobs.\nendpoint: \"workloads/me\"\n\n\n\n\n\n","category":"function"},{"location":"dev_notes/#Development-notes","page":"Development notes","title":"Development notes","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Pages = [\"dev_notes.md\"]\nDepth = 3","category":"page"},{"location":"dev_notes/#Native-Julia-types","page":"Development notes","title":"Native Julia types","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"The REST API is Python-centric in a few ways. Numerical data is typically numpy data that is serialized, compressed, and encoded.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"We currently support much of this with conversion to native-Julia types","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"numpy arrays are converted to Array\nPauli strings represented as un-processed strings by the REST API, eg. \"IXYZ\" are converted to PauliOperator (see below).\nBit-register samples (shots) are designed for compatibility with Qiskit's BitArray (or the other way around). We have a custom type with the same semantics and memory layout (more or less) in src/bitarraysx.jl. This has some associated functionality, but it is limited compared to, say, Base.BitArray. At present, a fallback conversion via BitArray(our_custom_array) works, and is not terribly inefficient if you don't do it much. We may want take a different approach. Eg, go directly to BitArray, or...\nQuantumCircuit. We leave this in the same form we get it from the REST API. A string of the serialized-compressed-encoded data.\nQASM3 programs. These are handled by the REST API as plain strings with no encoding. (maybe QASM3 allows utf-8, which receives standard encoding, IDK). We do nothing with this at the moment other than store it.","category":"page"},{"location":"dev_notes/#Precompile","page":"Development notes","title":"Precompile","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"precompile.jl script works by processing cached jobs in your ~/.qiskit directory. (We cache REST responses there, the Python client does not) If you have no cached jobs, then precompilation should still succeed, but it will not be of any benefit.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"This is not a good general solution. If someone installs the package, they will have no cached jobs,   and so get no benefit.","category":"page"},{"location":"dev_notes/#Name-spaces","page":"Development notes","title":"Name spaces","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Using modules to understand dependencies, and everything else good that they bring. I also want to keep symbols intended to be private out of the REPL TAB completion, and other prying tools. There are various methods in Julia-world to try to do this. I am sort of experimenting in an adhoc way","category":"page"},{"location":"dev_notes/#Data-structures","page":"Development notes","title":"Data structures","text":"","category":"section"},{"location":"dev_notes/#Dicts","page":"Development notes","title":"Dicts","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Discourage free-form dicts with string keys. Constrain values of inputs by construction. Eg. in Python, \"measure_noiselearning\" instead of \"measure_noise_learning\" gives an inscrutable error.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Of course, on the other hand, dict-based structures are easy to implement and change.","category":"page"},{"location":"dev_notes/#Version-numbers","page":"Development notes","title":"Version numbers","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"I am using VersionNumber rather than Int. There are stories in the software world of headaches that arise when people want to tighten up loose version number rules.","category":"page"},{"location":"dev_notes/#Bits-and-bit-base-storage","page":"Development notes","title":"Bits and bit-base storage","text":"","category":"section"},{"location":"dev_notes/#BitIntegers","page":"Development notes","title":"BitIntegers","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Has poor performance for some operations for large numbers of bits, say greater than UInt1024. I don't know how easy it would be to work around some of these. But I want to avoid even trying. There is at least one QC Julia package that uses these types for Pauli operators. For example: rand(UInt16384) fails to return in less than a several of minutes. I did not wait to see if it returns. I think this may be inefficient compilation. rand(UInt8192) takes about a minute for the first one. Then is much faster. But an order of mag longer than a corresponding array of UInt64. Seems to be an algorithmic inefficiency in compiling.","category":"page"},{"location":"dev_notes/#Pauli-operators","page":"Development notes","title":"Pauli operators","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"I have vendored PauliOperator from QuantumClifford.jl. The whole package is a bit heavier than I want at the moment. For most operations (but not all) PauliOperator is very fast, competitive with stim.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Sums of Pauli operators (or tables, etc.) Can be represented efficiently if the storage for each string is static and of the same size. Then they will be stored inline in a Vector. If we use dynamic storage, like a Vector{UInt64} or BitArray, then we probably do not want a Vector of our string type. They would not be stored inline. Unfortunately this story in Julia is not as good as it could be. There is some discussion about improvements, but they are not here yet.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Pauli type in QuantumClifford has good features, but bad perf in indexing ranges: data[1:10] My current experiment with storing data as a BitArray is 10x faster for this operation","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"I think the best for the moment is to depend on QuantumClifford. It is much bigger than just the relatively small code supporting Paulis. Some performance issues can be fixed easily outside of the package.","category":"page"},{"location":"dev_notes/#Load-times-and-[TTFX](https://www.google.com/search?qjuliattfx)","page":"Development notes","title":"Load times and TTFX","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"At the moment, I am trying vendoring to keep load and TTFX down. I plan to try Julia package Extensions","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Load times. I want to pay attention to load times, because this will be compared to the Python version.\nQuantumClifford – 1.3s. We use only a small part, PauliOperator. So, I vendored this.\nAccessors – 150ms this makes code much cleaner and easier to both read and write. But it depends  on InverseFunctions, which does compilation.\nPrecompileTools. This is working well to make TTFX very low. (EDIT: There has been a regression.  But the TTFX is still lower than it would be otherwise. I suspect we need more concrete type annotations.)","category":"page"},{"location":"dev_notes/#Performance","page":"Development notes","title":"Performance","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"LazyString: remember to use these when throwing exceptions.","category":"page"},{"location":"dev_notes/#Iterators-vs-containers","page":"Development notes","title":"Iterators vs containers","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"People, including myself, have noted that in Julia we miss the support for iterators that we find in Rust, and the culture around it. In Julia you have unnecessary allocation in chained operations on collections. I suspect that part of this difference is due to Julia playing two roles: one, a programming language; and two, an interactive tool. In the latter, containers are more convenient.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Still, I'd like to try to use more lazy containers. For example, I am trying this when returning things from the Requests layer. Since this layer is intended to be used primarily programmatically rather than interactively, you don't lose much convenience in returning, say Generator{Vector}.","category":"page"},{"location":"dev_notes/#Exceptions","page":"Development notes","title":"Exceptions","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Julia doesn't have a strong culture or concepts of best practices for exceptions.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Make our own exceptions, or use built in? When to use them?\nOr use an Option type?","category":"page"},{"location":"dev_notes/#Sum/Algebraic-types","page":"Development notes","title":"Sum/Algebraic types","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Speaking of Option types. How about a sum type?  These are often really useful.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"LightSumTypes.jl is very small (50 lines or so) and very performant, but lacks features.","category":"page"},{"location":"dev_notes/#Code-quality-and-CI","page":"Development notes","title":"Code quality and CI","text":"","category":"section"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Testing REST API. I think some kind mocking framework may be necessary.\nAqua.jl currently in use in this package.\nJET.jl. Would be a good idea. It is currently a bit painful to set up.\nQuantumClifford.jl","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"is an example of a Julia package that uses a bunch of GH Actions CI tools to enforce code quality","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"Enforced formatting? This is probably a good idea. I have not yet tried it. There is a newish package, Runic.jl, I think that is a config-less code formatter.","category":"page"},{"location":"dev_notes/","page":"Development notes","title":"Development notes","text":"<!--  LocalWords:  centric numpy un eg IXYZ PauliOperator Qiskit's BitArray src QASM3 utf\n  LocalWords:  QuantumCircuit IDK Precompile precompile jl qiskit precompilation REPL\n  LocalWords:  adhoc Dicts dicts noiselearning VersionNumber BitIntegers UInt1024 10x\n  LocalWords:  UInt16384 UInt8192 UInt64 vendored QuantumClifford stim perf Paulis 3s\n  LocalWords:  TTFX ttfx vendoring Accessors 150ms InverseFunctions PrecompileTools\n  LocalWords:  LazyString programmatically LightSumTypes performant GH newish config\n  LocalWords:  formatter\n-->","category":"page"},{"location":"accounts/#Accounts","page":"Accounts","title":"Accounts","text":"","category":"section"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"<!--\nI wish there were a way to put a section, such as \"Credentials file\" (below) in\na doc string in the source. For example in the docstring for `modules Account`.\nI *can* put it there. But it is not integrated semantically into the docs. And\nit is not rendered well, either.\n-->","category":"page"},{"location":"accounts/#credentials_file","page":"Accounts","title":"Credentials file","text":"","category":"section"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"danger: Danger\nAccount credentials are saved in plain text, so only do so if you are using a trusted device.","category":"page"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"In order to use the Qiskit Runtime service you need an account, and credentials for authentication.","category":"page"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"By default, the credentials are saved in the file","category":"page"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"$HOME/.qiskit/qiskit-ibm.json","category":"page"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"where $HOME is your home directory. QiskitRuntime can read this file, but cannot write it. You can create it with the Python client and/or edit it by hand.","category":"page"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"Which account is used for credentials may also be controlled with environment variables","category":"page"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"info: Info\nWe want to consistently use the term \"credentials file\" when referring to the file storing credentials for accounts. However, the word \"account\" is sometimes used. For example, the credentials file is read, and entries decoded into QuantumAccount objects.The Python code in qiskit-ibm-runtime sometimes uses the word fragment \"config\" in variables related to the credentials file, and its containing directory. We do not follow this convention.","category":"page"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"DocTestSetup = quote\n  set_env!(:QISKIT_USER_DIR, joinpath(pkgdir(QiskitRuntime), \"test\", \".qiskit\"))\nend","category":"page"},{"location":"accounts/#Functions-and-types","page":"Accounts","title":"Functions and types","text":"","category":"section"},{"location":"accounts/","page":"Accounts","title":"Accounts","text":"Modules = [QiskitRuntime.Accounts]","category":"page"},{"location":"accounts/#QiskitRuntime.Accounts.QuantumAccount","page":"Accounts","title":"QiskitRuntime.Accounts.QuantumAccount","text":"QuantumAccount(name=nothing)::QuantumAccount\n\nReturn a struct with information for making requests to the REST API.\n\nThe account argument may be omitted making requests to the server, for example when calling QiskitRuntime.Jobs.job. In these cases, the account will be constructed with the form QuantumAccount().\n\nThe following are tried in order, and the first to succeed is returned.\n\nIf name is not nothing then the account with this name is read from the credentials file.\nIf the account information is specified in enviroment variables QISKIT_IBM_INSTANCE and QISKIT_IBM_TOKEN, then these are used to construct the QuantumAccount. The credentials file is not read. (And need not exist.)\nIf the environment variable QISKIT_ACCOUNT_NAME is set, then this account is read from the credentials file.\nThe default account \"default-ibm-quantum\" is read from the credentials file.\n\nThe credentials file is typically ~/.qiskit/qiskit-ibm.json.\n\nIn case the account is constructed from environment variables, the variables QISKIT_IBM_CHANNEL, QISKIT_IBM_AUTH_URL may be set as well to override defaults.\n\nExamples\n\n(The tokens and instances below are invented, and are not related to any real account.)\n\njulia> accts = list_accounts() # List the accounts in the config file.\n2-element Vector{String}:\n \"default-ibm-quantum\"\n \"qiskit-other\"\n\njulia> QuantumAccount(accts[1]) # Get the first account\nQuantumAccount{Nothing}(\n  channel = \"ibm_quantum\",\n  auth_url = \"https://auth.quantum-computing.ibm.com/api\",\n  token = Token(\"de638e834a4925507bf4181220eff41d116a7baabd9a339cc2e8a3be570f6196cec2f3d77aabc773e1ae1e62ba67b3a5a7d0bbe9de015b89ec65692803c547e9\"),\n  instance = Instance(hub-one/group-one/project-one),\n  private_endpoint = false,\n  verify = false,\n  proxies = nothing\n)\n\njulia> QuantumAccount(accts[2]) # Get the second account\nQuantumAccount{Nothing}(\n  channel = \"ibm_quantum\",\n  auth_url = \"https://auth.quantum-computing.ibm.com/api\",\n  token = Token(\"726f2418e17c5845aad93c8e8a3cccaa642b9473132aaec47da93cb2f619fe3d156fb4962ebf8865bed278970bbddc3db0caf58c429b2fffd8c8c0359d80b43a\"),\n  instance = Instance(hub-two/group-two/project-two),\n  private_endpoint = false,\n  verify = false,\n  proxies = nothing\n)\n\njulia> QuantumAccount() # Get the default account, \"default-ibm-quantum\"\nQuantumAccount{Nothing}(\n  channel = \"ibm_quantum\",\n  auth_url = \"https://auth.quantum-computing.ibm.com/api\",\n  token = Token(\"de638e834a4925507bf4181220eff41d116a7baabd9a339cc2e8a3be570f6196cec2f3d77aabc773e1ae1e62ba67b3a5a7d0bbe9de015b89ec65692803c547e9\"),\n  instance = Instance(hub-one/group-one/project-one),\n  private_endpoint = false,\n  verify = false,\n  proxies = nothing\n)\n\nUsing QiskitRuntime.EnvVars.set_env!, we change the default account name with an environment variable.  To reduce verbosity, we just show the instance.\n\njulia> set_env!(:QISKIT_ACCOUNT_NAME, \"qiskit-other\");\n\njulia> QuantumAccount().instance\nInstance(hub-two/group-two/project-two)\n\nHere we set the account with environment variables, ignoring the credentials file.\n\njulia> set_env!(:QISKIT_IBM_TOKEN, \"f99b2a42c50ef0314434b0a5e60d8eab6b08112dd4259446e7172a34d61c48ea0a1b349e367dd62d7088fc0d0e97948f0d09fe46c4e34dd9550cdee97256e9a8\");\n\njulia> set_env!(:QISKIT_IBM_INSTANCE, \"a/b/c\");\n\njulia> QuantumAccount()\nQuantumAccount{Nothing}(\n  channel = \"ibm_quantum\",\n  auth_url = \"https://auth.quantum-computing.ibm.com/api\",\n  token = Token(\"f99b2a42c50ef0314434b0a5e60d8eab6b08112dd4259446e7172a34d61c48ea0a1b349e367dd62d7088fc0d0e97948f0d09fe46c4e34dd9550cdee97256e9a8\"),\n  instance = Instance(a/b/c),\n  private_endpoint = false,\n  verify = false,\n  proxies = nothing\n)\n\njulia> foreach(k -> set_env!(k, nothing), (:QISKIT_IBM_INSTANCE, :QISKIT_IBM_TOKEN, :QISKIT_ACCOUNT_NAME));\n\n\n\n\n\n\n","category":"type"},{"location":"accounts/#QiskitRuntime.Accounts.QuantumAccount-2","page":"Accounts","title":"QiskitRuntime.Accounts.QuantumAccount","text":"struct that stores credentials data for an account.\"\n\n\n\n\n\n","category":"type"},{"location":"accounts/#QiskitRuntime.Accounts.all_accounts-Tuple{}","page":"Accounts","title":"QiskitRuntime.Accounts.all_accounts","text":"all_accounts() :: Vector{QuantumAccount}\n\nReturn a list of all QuantumAccounts in the user's credentials file.\n\n\n\n\n\n","category":"method"},{"location":"accounts/#QiskitRuntime.Accounts.list_accounts-Tuple{}","page":"Accounts","title":"QiskitRuntime.Accounts.list_accounts","text":"list_accounts() :: Vector{String}\n\nReturn a list of all account names from the user's credentials file.\n\n\n\n\n\n","category":"method"},{"location":"#QiskitRuntime.jl","page":"Introduction","title":"QiskitRuntime.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThis documentation is not for the standard client qiskit-ibm-runtime to the Qiskit Runtime REST APITo find information on the easiest, best, way to use the Qiskit Runtime use this link:qiskit-ibm-runtimeThe documentation you are reading now is only for the highly experimental Julia-language client, not for the Python-langauge client.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nDocumentation pages for QiskitRuntime.jl are a WIP.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using QiskitRuntime\nend","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"See also the Development notes.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\", \"tutorial.md\", \"accounts.md\", \"env_vars.md\", \"requests.md\", \"ids.md\", \"theindex.md\"]\nDepth = 2","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n  set_env!(:QISKIT_USER_DIR, joinpath(pkgdir(QiskitRuntime), \"test\", \".qiskit\"))\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime]","category":"page"},{"location":"#QiskitRuntime.QiskitRuntime","page":"Introduction","title":"QiskitRuntime.QiskitRuntime","text":"module QiskitRuntime\n\nQiskitRuntime is a client for the Qiskit Runtime REST API written in the Julia language.\n\nQiskitRuntime is analagous to the Python-language client qiskit-ibm-runtime.\n\nwarning: Warning\nQiskitRuntime is very new, incomplete, and API-unstable.QiskitRuntime.jl is completely unsupported. No person or entity is responsible for providing any support to users of this software.\n\nAccounts\n\nMany functions, such as job, jobs, user take an optional argument account. If account is omitted, then information will be taken from the user's config file ~/.qisit/qiskit-ibm.json, or environment variables. The environment variables will be preferred. See Accounts.QuantumAccount.\n\nLayers\n\nThere are more or less two layers: An interface to the REST API, and a layer on top that returns data of native and custom Julia types.\n\nCaching\n\nCaching is done at the level of entire REST API responses.\n\nReponses from several endpoints are cached automatically. They can be updated with refresh=true. For example Requests.job(job_id; refresh=true).\n\nFunctions in the upper layer also take the keyword argument refresh and pass it to the Requests layer. For example Jobs.job(job_id; refresh=true).\n\nCaching is done by dumping the REST responses via JSON3 in ~/.qiskit/runtime_cache/.\n\n\n\n\n\n","category":"module"},{"location":"#Jobs","page":"Introduction","title":"Jobs","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime.Jobs]","category":"page"},{"location":"#QiskitRuntime.Jobs.Cancelled","page":"Introduction","title":"QiskitRuntime.Jobs.Cancelled","text":"job has been cancelled\n\n\n\n\n\n","category":"constant"},{"location":"#QiskitRuntime.Jobs.Done","page":"Introduction","title":"QiskitRuntime.Jobs.Done","text":"job has successfully run\n\n\n\n\n\n","category":"constant"},{"location":"#QiskitRuntime.Jobs.Error","page":"Introduction","title":"QiskitRuntime.Jobs.Error","text":"job incurred error\n\n\n\n\n\n","category":"constant"},{"location":"#QiskitRuntime.Jobs.Queued","page":"Introduction","title":"QiskitRuntime.Jobs.Queued","text":"job is queued\n\n\n\n\n\n","category":"constant"},{"location":"#QiskitRuntime.Jobs.Running","page":"Introduction","title":"QiskitRuntime.Jobs.Running","text":"job is actively running\n\n\n\n\n\n","category":"constant"},{"location":"#QiskitRuntime.Jobs.JobStatus","page":"Introduction","title":"QiskitRuntime.Jobs.JobStatus","text":"JobStatus\n\nStatus of a job as reported by a query to the Runtime.\n\nQueued\nRunning\nDone\nError\nCancelled\n\n\n\n\n\n","category":"type"},{"location":"#QiskitRuntime.Jobs.cached_job_ids-Tuple{}","page":"Introduction","title":"QiskitRuntime.Jobs.cached_job_ids","text":"cached_job_ids()\n\nReturn an iterator over JobIds of cached jobs.\n\nUse job_ids to request ids from the REST API.\n\n\n\n\n\n","category":"method"},{"location":"#QiskitRuntime.Jobs.cached_jobs-Tuple{}","page":"Introduction","title":"QiskitRuntime.Jobs.cached_jobs","text":"cached_jobs(; params::Bool=true, results::Bool=true)\n\nReturn an iterator over all cached jobs.\n\nparams: If true include job input parameters (including the pubs).  Otherwise the field params has           value nothing.\nresults: If true get the job results, if available. Otherwise, the field results has value nothing.\n\n\n\n\n\n","category":"method"},{"location":"#QiskitRuntime.Jobs.job","page":"Introduction","title":"QiskitRuntime.Jobs.job","text":"job(job_in::RuntimeJob, account=nothing;  params::Bool=true, results::Bool=true, refresh::Bool=false)::RuntimeJob\n\nReturn information on job_in.\n\nThe fields job_in.params and job_in.results may have value nothing. Use this method to return a copy of job_in with one or both of these fields populated, according to the keyword arguments params and results. These keyword arguments are described in job\n\nnote: Note\nThis function would be more useful if it were optimized to fetch only the needed additional data, copying the rest from jobin. In fact, at present, it constructs the entire RuntimeJob from scratch.\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.job-2","page":"Introduction","title":"QiskitRuntime.Jobs.job","text":"job(job_id::JobId, account=nothing;  params::Bool=true, results::Bool=true, refresh::Bool=false)::RuntimeJob\n\nReturn information on job_id.\n\nparams: If true include job input parameters (including the PUBs)).           Otherwise the field params has value nothing.\nresults: If true get the job results, if available. Otherwise, the field results has value nothing.            Results are retrieved via the function results.\nrefresh: If true fetch job info and results from the REST API, rather than from cache.            This also updates the cache. If refresh is false, then the cache is preferred.\n\nSee results\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.job_ids","page":"Introduction","title":"QiskitRuntime.Jobs.job_ids","text":"job_ids(account=nothing)\n\nReturn an iterator over JobIds for all jobs.\n\njob_ids first requests all the information on the jobs, then extracts the ids. This function always makes requests to the REST API and does not access the cache.\n\nUse cached_job_ids to get ids only for cached job requests.\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.results","page":"Introduction","title":"QiskitRuntime.Jobs.results","text":"results(job_id, account=nothing; refresh=false)\n\nReturn results for job_id.\n\nSee job\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.results-2","page":"Introduction","title":"QiskitRuntime.Jobs.results","text":"results(job::RuntimeJob, account=nothing; refresh=false)\n\nReturn results associated with job.\n\nResults already contained in job are returned if it makes sense to do so.\n\nMore precisely, if job.results is not nothing and refresh is false, then job.results is returned. If job.results is nothing then results are fetched from the cache or the REST API. If refresh is false then the cache is preferred.\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.run_job","page":"Introduction","title":"QiskitRuntime.Jobs.run_job","text":"run_job(backend_name::AbstractString, pubs::AbstractVector{<:AbstractPUB}, qaccount=nothing)\n\nRun pubs on device backend_name.\n\nParameters for controlling error mitigation are not yet supported.\n\nSee Accounts.QuantumAccount, PUBs.EstimatorPUB, PUBs.SamplerPUB, Backends.backends.\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Jobs.user_info","page":"Introduction","title":"QiskitRuntime.Jobs.user_info","text":"user_info(account=nothing; refresh=false)::UserInfo\n\nReturn information about the user.\n\nInformation includes the user's email and a list of available instances.\n\nnote: Note\nThe user info returned by the server is determined by the authentication token. Unlike other cached information, we do not key the cache by this information in order to avoid writing the token as plain text. So if you have more than one account, each with an associated token, the cache will not distinguish them. If you switch accounts and tokens, you should pass refresh=true.If you merely generate and use a new token for a single account, you do not need to refresh the cache.\n\n\n\n\n\n","category":"function"},{"location":"#Backends","page":"Introduction","title":"Backends","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime.Backends]","category":"page"},{"location":"#QiskitRuntime.Backends.backend_status","page":"Introduction","title":"QiskitRuntime.Backends.backend_status","text":"backend_status(backend_name::AbstractString, account=nothing)\n\nReturn status information of backend_name.\n\n\n\n\n\n","category":"function"},{"location":"#QiskitRuntime.Backends.backends","page":"Introduction","title":"QiskitRuntime.Backends.backends","text":"backends(account=nothing; pending=false, testing=false, instance=nothing)\n\nReturn a list of available backends.\n\npending: If true, return a list of tuples  (name, num_pending_jobs) sorted by num_pending_jobs.\ntesting: If true include test devices, those that begin with \"test_\".\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    set_env!(:QISKIT_IBM_TOKEN, nothing)\n    set_env!(:QISKIT_IBM_INSTANCE, nothing)\nend","category":"page"},{"location":"#Instances","page":"Introduction","title":"Instances","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime.Instances]","category":"page"},{"location":"#QiskitRuntime.Instances.Instance-Tuple{AbstractString}","page":"Introduction","title":"QiskitRuntime.Instances.Instance","text":"Instance(instance::AbstractString)\n\nConstruct an Instance from a string of the form \"hub/group/project\".\n\njulia> inst = Instance(\"a_hub/a_group/a_project\")\nInstance(a_hub/a_group/a_project)\n\njulia> inst.project\n\"a_project\"\n\njulia> Instance(\"a_hub/a_group/a_project/\")\nERROR: ArgumentError: Expecting three parts separated by '/'. Got 4 parts\n\n\n\n\n\n","category":"method"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    delete!(ENV, \"QISKIT_CONFIG_DIR\")\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = nothing","category":"page"},{"location":"#PUBs","page":"Introduction","title":"PUBs","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime.PUBs]","category":"page"},{"location":"#QiskitRuntime.PUBs.EstimatorPUB","page":"Introduction","title":"QiskitRuntime.PUBs.EstimatorPUB","text":"EstimatorPUB{CircT, ParamsT}\n\nA PUB for the Estimator primitive.\n\n\n\n\n\n","category":"type"},{"location":"#QiskitRuntime.PUBs.SamplerPUB","page":"Introduction","title":"QiskitRuntime.PUBs.SamplerPUB","text":"SamplerPUB{CircT, ParamsT}\n\nA PUB for the Sampler primitive.\n\n\n\n\n\n","category":"type"},{"location":"#Circuits","page":"Introduction","title":"Circuits","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [QiskitRuntime.Circuits]","category":"page"},{"location":"#QiskitRuntime.Circuits.CircuitString","page":"Introduction","title":"QiskitRuntime.Circuits.CircuitString","text":"struct CircuitString\n\nSerialized, compressed, encoded data  of Python QuantumCircuit type\n\nThe QuantumCircuit was serialized as qpy, then compressed with zlib, then base64 encoded.\n\n\n\n\n\n","category":"type"},{"location":"#QiskitRuntime.Circuits.QASMString","page":"Introduction","title":"QiskitRuntime.Circuits.QASMString","text":"QASMString\n\nOpenQASM 3 program as a String.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is not a really tutorial. It's a demonstration of a few things that you can try","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nThis tutorial assumes you have valid account info in ~/.qiskit/qiskit-ibm.json.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nI would be surprised if this works for you on the first attempt. This was all developed in a particular environment, with a particular subset of the data returned by the REST API.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pull in a lot of symbols.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using QiskitRuntime","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also get exported symbols from only one module, e.g. using QiskitRuntime.Jobs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Retrieve job ids from the server. Note that an iterator is returned. So we use collect.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ajob_ids = collect(job_ids());\n\njulia> print(ajob_ids[1:5])\nJobId[JobId(\"cxp4fhy0v15000804nsg\"), JobId(\"cxp4fhpwk6yg008hjy5g\"), JobId(\"cxd6a7rbqkhg008kef50\"), JobId(\"cxd6a70pjw30008g32y0\"), JobId(\"cxd6a60px23g008t7nz0\")]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Fetch the \"jobs\", that is input information and results, for each job id. Note that we choose to throw the returned objects away. But they are cached in ~/.qiskit/runtime_cache.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> foreach(jid -> job(jid; refresh=true), ajob_ids)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We used refresh=true to make sure we fetch data from the server, not from the cache.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can get the (freshly) cached job ids like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> jids = collect(cached_job_ids()); length(jids)\n39\n\njulia> jid = jids[end]\nJobId(\"wlv2rkrosk0uef9vfhpy\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now fetching the GET response from the cache, and decoding it (including native Julia types) is fast, even though it is not optimized at all.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @btime job($jid);\n  414.767 μs (12001 allocations: 564.11 KiB)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In general, job(jid) will build a big nested object. So I don't print one of them here. However, you can request that the results and job parameters params (including the input PUBs) be omitted.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> job(jid; results=false, params=false)\nRuntimeJob{Nothing, Nothing}(\n  job_id = JobId(\"wlv2rkrosk0uef9vfhpy\"),\n  user_id = QiskitRuntime.Accounts.UserId(\"XXXXXXXXXXXXXXXXXXXXXXXX\"),\n  session_id = JobId(\"wlv2rkrosk0uef9vfhpy\"),\n  primitive_id = Estimator::PrimitiveType = 0,\n  backend_name = \"ibm_brisbane\",\n  creation_date = 2024-12-25T17:58:31.640,\n  end_date = 2024-12-25T18:12:12.882,\n  instance = Instance(my-hub/my-group/my-project),\n  status = Done::JobStatus = 2,\n  cost = 18000,\n  private = false,\n  tags = [\"everything\", \"PEC\", \"Container Tests\"],\n  params = nothing,\n  results = nothing\n)","category":"page"}]
}
