<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Development notes · QiskitRuntime</title><meta name="title" content="Development notes · QiskitRuntime"/><meta property="og:title" content="Development notes · QiskitRuntime"/><meta property="twitter:title" content="Development notes · QiskitRuntime"/><meta name="description" content="Documentation for QiskitRuntime."/><meta property="og:description" content="Documentation for QiskitRuntime."/><meta property="twitter:description" content="Documentation for QiskitRuntime."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QiskitRuntime</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../accounts/">Accounts</a></li><li><a class="tocitem" href="../env_vars/">Environment Variables</a></li><li><a class="tocitem" href="../requests/">Requests</a></li><li><a class="tocitem" href="../ids/">Id Numbers and Tokens</a></li><li class="is-active"><a class="tocitem" href>Development notes</a><ul class="internal"><li><a class="tocitem" href="#Native-Julia-types"><span>Native Julia types</span></a></li><li><a class="tocitem" href="#Precompile"><span>Precompile</span></a></li><li><a class="tocitem" href="#Name-spaces"><span>Name spaces</span></a></li><li><a class="tocitem" href="#Data-structures"><span>Data structures</span></a></li><li><a class="tocitem" href="#Load-times-and-[TTFX](https://www.google.com/search?qjuliattfx)"><span>Load times and TTFX</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li><li><a class="tocitem" href="#Exceptions"><span>Exceptions</span></a></li><li><a class="tocitem" href="#Sum/Algebraic-types"><span>Sum/Algebraic types</span></a></li><li><a class="tocitem" href="#Code-quality-and-CI"><span>Code quality and CI</span></a></li></ul></li><li><a class="tocitem" href="../theindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Development notes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Development notes</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Development-notes"><a class="docs-heading-anchor" href="#Development-notes">Development notes</a><a id="Development-notes-1"></a><a class="docs-heading-anchor-permalink" href="#Development-notes" title="Permalink"></a></h1><ul><li><a href="#Development-notes">Development notes</a></li><li class="no-marker"><ul><li><a href="#Native-Julia-types">Native Julia types</a></li><li><a href="#Precompile">Precompile</a></li><li><a href="#Name-spaces">Name spaces</a></li><li><a href="#Data-structures">Data structures</a></li><li class="no-marker"><ul><li><a href="#Dicts">Dicts</a></li><li><a href="#Version-numbers">Version numbers</a></li><li><a href="#Bits-and-bit-base-storage">Bits and bit-base storage</a></li><li><a href="#Pauli-operators">Pauli operators</a></li></ul></li><li><a href="#Load-times-and-[TTFX](https://www.google.com/search?qjuliattfx)">Load times and TTFX</a></li><li><a href="#Performance">Performance</a></li><li class="no-marker"><ul><li><a href="#Iterators-vs-containers">Iterators vs containers</a></li></ul></li><li><a href="#Exceptions">Exceptions</a></li><li><a href="#Sum/Algebraic-types">Sum/Algebraic types</a></li><li><a href="#Code-quality-and-CI">Code quality and CI</a></li></ul></li></ul><h2 id="Native-Julia-types"><a class="docs-heading-anchor" href="#Native-Julia-types">Native Julia types</a><a id="Native-Julia-types-1"></a><a class="docs-heading-anchor-permalink" href="#Native-Julia-types" title="Permalink"></a></h2><p>The REST API is Python-centric in a few ways. Numerical data is typically numpy data that is serialized, compressed, and encoded.</p><p>We currently support much of this with conversion to native-Julia types</p><ul><li>numpy arrays are converted to <code>Array</code></li><li>Pauli strings represented as un-processed strings by the REST API, eg. &quot;IXYZ&quot; are converted to <code>PauliOperator</code> (see below).</li><li>Bit-register samples (shots) are designed for compatibility with Qiskit&#39;s <a href="https://github.com/Qiskit/qiskit/blob/main/qiskit/primitives/containers/bit_array.py">BitArray</a> (or the other way around). We have a custom type with the same semantics and memory layout (more or less) in src/bitarraysx.jl. This has some associated functionality, but it is limited compared to, say, <code>Base.BitArray</code>. At present, a fallback conversion via <code>BitArray(our_custom_array)</code> works, and is not terribly inefficient if you don&#39;t do it much. We may want take a different approach. Eg, go directly to <code>BitArray</code>, or...</li><li><code>QuantumCircuit</code>. We leave this in the same form we get it from the REST API. A string of the serialized-compressed-encoded data.</li><li>QASM3 programs. These are handled by the REST API as plain strings with no encoding. (maybe QASM3 allows utf-8, which receives standard encoding, IDK). We do nothing with this at the moment other than store it.</li></ul><h2 id="Precompile"><a class="docs-heading-anchor" href="#Precompile">Precompile</a><a id="Precompile-1"></a><a class="docs-heading-anchor-permalink" href="#Precompile" title="Permalink"></a></h2><ul><li>precompile.jl script works by processing cached jobs in your <code>~/.qiskit</code> directory. (We cache REST responses there, the Python client does not) If you have no cached jobs, then precompilation should still succeed, but it will not be of any benefit.</li></ul><p>This is not a good general solution. If someone installs the package, they will have no cached jobs,   and so get no benefit.</p><h2 id="Name-spaces"><a class="docs-heading-anchor" href="#Name-spaces">Name spaces</a><a id="Name-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Name-spaces" title="Permalink"></a></h2><p>Using modules to understand dependencies, and everything else good that they bring. I also want to keep symbols intended to be private out of the REPL TAB completion, and other prying tools. There are various methods in Julia-world to try to do this. I am sort of experimenting in an adhoc way</p><h2 id="Data-structures"><a class="docs-heading-anchor" href="#Data-structures">Data structures</a><a id="Data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-structures" title="Permalink"></a></h2><h3 id="Dicts"><a class="docs-heading-anchor" href="#Dicts">Dicts</a><a id="Dicts-1"></a><a class="docs-heading-anchor-permalink" href="#Dicts" title="Permalink"></a></h3><p>Discourage free-form dicts with string keys. Constrain values of inputs by construction. Eg. in Python, <code>&quot;measure_noiselearning&quot;</code> instead of <code>&quot;measure_noise_learning&quot;</code> gives an inscrutable error.</p><p>Of course, on the other hand, dict-based structures are easy to implement and change.</p><h3 id="Version-numbers"><a class="docs-heading-anchor" href="#Version-numbers">Version numbers</a><a id="Version-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Version-numbers" title="Permalink"></a></h3><p>I am using <code>VersionNumber</code> rather than <code>Int</code>. There are stories in the software world of headaches that arise when people want to tighten up loose version number rules.</p><h3 id="Bits-and-bit-base-storage"><a class="docs-heading-anchor" href="#Bits-and-bit-base-storage">Bits and bit-base storage</a><a id="Bits-and-bit-base-storage-1"></a><a class="docs-heading-anchor-permalink" href="#Bits-and-bit-base-storage" title="Permalink"></a></h3><h4 id="BitIntegers"><a class="docs-heading-anchor" href="#BitIntegers"><code>BitIntegers</code></a><a id="BitIntegers-1"></a><a class="docs-heading-anchor-permalink" href="#BitIntegers" title="Permalink"></a></h4><p>Has poor performance for some operations for large numbers of bits, say greater than <code>UInt1024</code>. I don&#39;t know how easy it would be to work around some of these. But I want to avoid even trying. There is at least one QC Julia package that uses these types for Pauli operators. For example: <code>rand(UInt16384)</code> fails to return in less than a several of minutes. I did not wait to see if it returns. I think this may be inefficient compilation. <code>rand(UInt8192)</code> takes about a minute for the first one. Then is much faster. But an order of mag longer than a corresponding array of <code>UInt64</code>. Seems to be an algorithmic inefficiency in compiling.</p><h3 id="Pauli-operators"><a class="docs-heading-anchor" href="#Pauli-operators">Pauli operators</a><a id="Pauli-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Pauli-operators" title="Permalink"></a></h3><p>I have vendored <code>PauliOperator</code> from <code>QuantumClifford.jl</code>. The whole package is a bit heavier than I want at the moment. For most operations (but not all) <code>PauliOperator</code> is very fast, competitive with stim.</p><p>Sums of Pauli operators (or tables, etc.) Can be represented efficiently if the storage for each string is static and of the same size. Then they will be stored inline in a Vector. If we use dynamic storage, like a <code>Vector{UInt64}</code> or <code>BitArray</code>, then we probably do not want a <code>Vector</code> of our string type. They would not be stored inline. Unfortunately this story in Julia is not as good as it could be. There is some discussion about improvements, but they are not here yet.</p><p>Pauli type in <code>QuantumClifford</code> has good features, but bad perf in indexing ranges: <code>data[1:10]</code> My current experiment with storing data as a BitArray is 10x faster for this operation</p><p>I think the best for the moment is to depend on <code>QuantumClifford</code>. It is much bigger than just the relatively small code supporting Paulis. Some performance issues can be fixed easily outside of the package.</p><h2 id="Load-times-and-[TTFX](https://www.google.com/search?qjuliattfx)"><a class="docs-heading-anchor" href="#Load-times-and-[TTFX](https://www.google.com/search?qjuliattfx)">Load times and <a href="https://www.google.com/search?q=julia+ttfx">TTFX</a></a><a id="Load-times-and-[TTFX](https://www.google.com/search?qjuliattfx)-1"></a><a class="docs-heading-anchor-permalink" href="#Load-times-and-[TTFX](https://www.google.com/search?qjuliattfx)" title="Permalink"></a></h2><p>At the moment, I am trying vendoring to keep load and TTFX down. I plan to try Julia package <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions)">Extensions</a></p><ul><li><p>Load times. I want to pay attention to load times, because this will be compared to the Python version.</p><ul><li><code>QuantumClifford</code> – 1.3s. We use only a small part, <code>PauliOperator</code>. So, I vendored this.</li><li><code>Accessors</code> – 150ms this makes code much cleaner and easier to both read and write. But it depends  on <code>InverseFunctions</code>, which does compilation.</li></ul></li><li><p><code>PrecompileTools</code>. This is working well to make TTFX very low. (EDIT: There has been a regression.  But the TTFX is still lower than it would be otherwise. I suspect we need more concrete type annotations.)</p></li></ul><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><ul><li><code>LazyString</code>: remember to use these when throwing exceptions.</li></ul><h3 id="Iterators-vs-containers"><a class="docs-heading-anchor" href="#Iterators-vs-containers">Iterators vs containers</a><a id="Iterators-vs-containers-1"></a><a class="docs-heading-anchor-permalink" href="#Iterators-vs-containers" title="Permalink"></a></h3><p>People, including myself, have noted that in Julia we miss the support for iterators that we find in Rust, and the culture around it. In Julia you have unnecessary allocation in chained operations on collections. I suspect that part of this difference is due to Julia playing two roles: one, a programming language; and two, an interactive tool. In the latter, containers are more convenient.</p><p>Still, I&#39;d like to try to use more lazy containers. For example, I am trying this when returning things from the <code>Requests</code> layer. Since this layer is intended to be used primarily programmatically rather than interactively, you don&#39;t lose much convenience in returning, say <code>Generator{Vector}</code>.</p><h2 id="Exceptions"><a class="docs-heading-anchor" href="#Exceptions">Exceptions</a><a id="Exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Exceptions" title="Permalink"></a></h2><p>Julia doesn&#39;t have a strong culture or concepts of best practices for exceptions.</p><ul><li><p>Make our own exceptions, or use built in? When to use them?</p></li><li><p>Or use an <code>Option</code> type?</p></li></ul><h2 id="Sum/Algebraic-types"><a class="docs-heading-anchor" href="#Sum/Algebraic-types">Sum/Algebraic types</a><a id="Sum/Algebraic-types-1"></a><a class="docs-heading-anchor-permalink" href="#Sum/Algebraic-types" title="Permalink"></a></h2><p>Speaking of <code>Option</code> types. How about a sum type?  These are often really useful.</p><ul><li><a href="https://github.com/JuliaDynamics/LightSumTypes.jl">LightSumTypes.jl</a> is very small (50 lines or so) and very performant, but lacks features.</li></ul><h2 id="Code-quality-and-CI"><a class="docs-heading-anchor" href="#Code-quality-and-CI">Code quality and CI</a><a id="Code-quality-and-CI-1"></a><a class="docs-heading-anchor-permalink" href="#Code-quality-and-CI" title="Permalink"></a></h2><ul><li><p>Testing REST API. I think some kind mocking framework may be necessary.</p></li><li><p><a href="https://github.com/JuliaTesting/Aqua.jl">Aqua.jl</a> currently in use in this package.</p></li><li><p><code>JET.jl</code>. Would be a good idea. It is currently a bit painful to set up.</p></li><li><p><a href="https://github.com/QuantumSavory/QuantumClifford.jl">QuantumClifford.jl</a></p></li></ul><p>is an example of a Julia package that uses a <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/master/.github/workflows">bunch of GH Actions CI tools</a> to enforce code quality</p><ul><li>Enforced formatting? This is probably a good idea. I have not yet tried it. There is a newish package, <code>Runic.jl</code>, I think that is a config-less code formatter.</li></ul><!--  LocalWords:  centric numpy un eg IXYZ PauliOperator Qiskit's BitArray src QASM3 utf
  LocalWords:  QuantumCircuit IDK Precompile precompile jl qiskit precompilation REPL
  LocalWords:  adhoc Dicts dicts noiselearning VersionNumber BitIntegers UInt1024 10x
  LocalWords:  UInt16384 UInt8192 UInt64 vendored QuantumClifford stim perf Paulis 3s
  LocalWords:  TTFX ttfx vendoring Accessors 150ms InverseFunctions PrecompileTools
  LocalWords:  LazyString programmatically LightSumTypes performant GH newish config
  LocalWords:  formatter
--></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ids/">« Id Numbers and Tokens</a><a class="docs-footer-nextpage" href="../theindex/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 2 January 2025 00:40">Thursday 2 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
